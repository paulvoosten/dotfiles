#! /bin/sh
# coloring variables
reset='\e[0m'
# black & gray
color0='\e[0;30m'
color8='\e[1;30m'

# red
color1='\e[0;31m'
color9='\e[1;31m'

# green
color2='\e[0;32m'
color10='\e[1;32m'

# yellow
color3='\e[0;33m'
color11='\e[1;33m'

# blue
color4='\e[0;34m'
color12='\e[1;34m'

# purple
color5='\e[0;35m'
color13='\e[1;35m'

# teal
color6='\e[0;36m'
color14='\e[1;36m'

# silver & white
color7='\e[0;37m'
color15='\e[1;37m'

git_prompt() {
    # local prompt=''
    # local branch="${white} "

    # # check if the current directory is in a Git repository.
    # if [ $(git rev-parse --is-inside-work-tree &> /dev/null; echo "${?}") == '0' ]; then
    #     # check if the current directory is in .git before running git checks
    #     if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then
    #         # ensure the index is up to date.
    #         git update-index --really-refresh -q &> /dev/null

    #         # check for uncommitted changes in the index.
    #         if ! $(git diff --quiet --ignore-submodules --cached); then
    #             prompt+='+'
    #         fi

    #         # check for unstaged changes.
    #         if ! $(git diff-files --quiet --ignore-submodules --); then
    #             prompt+='!'
    #         fi

    #         # check for untracked files.
    #         if [ -n "$(git ls-files --others --exclude-standard)" ]; then
    #             prompt+='?'
    #         fi

    #         # check for stashed files.
    #         if $(git rev-parse --verify refs/stash &> /dev/null); then
    #             prompt+='$'
    #         fi
    #     fi

    #     branch+="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
    #         git rev-parse --short HEAD 2> /dev/null || \
    #         echo '(unknown)')"
    #     [ -n "${prompt}" ] && prompt=" [${prompt}]"
    #     echo -e " ${branch}${prompt}"
    # else
    #     return
    # fi
    local prompt=''
    local branch=''

    # check if current directory is a git repo
    if [ $(git rev-parse --is-inside-work-tree &> /dev/null; echo "${?}") == '0' ]; then
        # check if current directory is in .git before running git checks
        if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then
            git update-index --realy-refresh -q &> /dev/null

            # check for uncommited files
            if ! $(git diff --quiet --ignore-submodules --cached); then
                prompt+='+'
            fi

            # check for unstaged files
            if ! $(git diff-files --quiet --ignore-submodules --); then
                prompt+='!'
            fi

            # check for untracked files
            if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                prompt+='?'
            fi

            #check for stashed files
            if $(git rev-parse --verify refs/stash &> /dev/null); then
                prompt+='$'
            fi
        fi

        branch+="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            git rev-parse --short HEAD 2> /dev/null || \
            echo '(unknown)')"
        [ -n "${prompt}" ] && prompt="[${prompt}]"

        echo -e "${1}${branch} ${2}${prompt}"
    else
        return
    fi
}

# change color of username when root
if [[ "$USER" == "root" ]]; then
    user_color="${color9}"
else
    user_color="${color15}"
fi;

# change color if connected with SSH
if [[ "${SSH_TTY}" ]]; then
    host_color="${color9}"
else
    host_color="${color15}"
fi

# todo fix status color so it changes based on last executed command (red == failed)
if [[ "${?}" == '0' ]]; then
    status_color="${color10}"
else
    status_color="${color9}"
fi

# status_color="\$(if [[ \$? == 0 ]]; then echo \"${color10}\"; else echo \"${color9}\"; fi)"

PS1="\[${user_color}\]\u"
PS1+="\[${color10}\]@"
PS1+="\[${host_color}\]\h:"
PS1+="\[${color10}\] \w"
PS1+="\$(git_prompt \"\[${color15}\]  \[${color11}\]\" \"\[${color12}\]\")\n"
PS1+="\[${status_color}\]$ \[${reset}\]"

PS2="\[${status_color}\] \[${reset}\]"

export PS1
export PS2

# source /usr/share/git/completion/git-prompt.sh

# bash_prompt () {
#     # Checks to see if the current directory is a git repo or not
#     gitcheck_branch="$(git branch &>/dev/null; if [ $? -eq 0 ]; then echo 'yes'; else echo 'no'; fi)"

#     if [ $gitcheck_branch == 'yes' ]; then
#         # If we are in a git repo, then check to see if there are uncommitted files
#         gitcheck_status="$(git status | grep 'nothing to commit' > /dev/null 2>&1; if [ $? -eq 0 ]; then echo 'clean'; else echo 'dirty'; fi)"

#         if [ $gitcheck_status == 'clean' ]; then
#             # If there are no uncommitted files, then set the color of the git branch name to green
#             git_prompt=" ${light_blue}${light_green}$(__git_ps1)"
#         else
#             # If there are uncommitted files, set it to red.
#             git_prompt=" ${light_blue}${light_red}$(__git_ps1)"
#         fi
#     else
#         # If we're not in a git repo, then display nothing
#         git_prompt=""
#     fi

#     # if [[ $? == 0 ]]; then
#     #     status_color="${light_green}"
#     # else
#     #     status_color="${light_red}"
#     # fi
#     status_color="\$(if [[ \$? == 0 ]]; then echo \"${light_green}\"; else echo \"${light_red}\"; fi)"

#     PS1="${white}\u${light_green}@${white}\h: \w${git_prompt}\n${status_color}$ ${reset}"
#     PS2="${status_color} ${reset}"
# }
